#!/usr/bin/python3

import os
import math
import argparse


def make_divider(divisor: float, bits: int, guard_define: str, gnu: bool = False) -> str | None:
    p = math.ceil(math.log2(divisor))
    m = math.ceil((1 << (args.b + p)) / args.divisor) & ((1 << args.b) - 1)

    types = {n: f"uint{n}_t" for n in [8, 16, 32, 64]}
    if gnu:
        types[128] = "__uint128_t"

    if bits*2 not in types.keys():
        print("Can't generate bit width", bits, "- requires", bits*2, "bit type")
        return None

    itype = types[bits]
    ltype = types[bits*2]

    return f"""// Generated by {os.path.basename(__file__)}

#ifndef {guard_define}
#define {guard_define}

#include <stdint.h>

// Divide by {divisor}
static inline {itype} {args.n}({itype} n) {{
    {itype} q = ((({ltype}) {m}ULL)*(({ltype}) n)) >> {args.b}ULL;
    {itype} t = (((n - q) >> 1) + q) >> {p-1};
    return t;
}}

#endif
"""

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        "Generates a function to perform floor division by a constant in standard C "
        "via the method here:\n"
        "https://ridiculousfish.com/blog/posts/labor-of-division-episode-i.html\n\n"
        "Bit widths of up to 32 bits (64 on GCC) are supported, and results will be "
        "exact to integer truncation. Floating-point divisors are also supported. "
        "(If you have a modern compiler and are only using integers, your compiler "
        "probably does this already.)\n"
    )

    parser.add_argument("-o", type=str, help="Output header file")
    parser.add_argument("-b", type=int, help="Bit width of calculation", default=32)
    parser.add_argument("-n", type=str, help="Name of function generated")
    parser.add_argument("-g", action='store_true',
                        help="Assume support for GNU-style __uint128_t (otherwise "
                        "64-bit upper multiplies can't be generated)")
    parser.add_argument("divisor", type=float, help="Number to divide by")

    args = parser.parse_args()

    if args.o is not None:
        guard_define = os.path.basename(args.o).upper()\
            .translate({ord(c): "_" for c in "\"\'!@#$%^&*()[]{};:,./<>?\\|`~-=+"})
    else:
        guard_define = "DIVIDER_H"


    if args.divisor <= 0:
        print("Only positive divisors supported")
        exit(-1)

    if args.n is None:
        args.n = "div_" + str(args.divisor).replace(".", "_")

    code_str = make_divider(args.divisor, args.b, guard_define, args.g)
    if code_str is None:
        exit(-1)

    if args.o is not None:
        with open(args.o, "w") as f:
            f.write(code_str)
    else:
        print(code_str)
