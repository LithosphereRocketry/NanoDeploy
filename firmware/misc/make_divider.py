#!/usr/bin/python3

import os
import math
import argparse


def make_divider(divisor: float, bits: int, name: str, guard_define: str | None = None, gnu: bool = False, signed: bool = False) -> str | None:
    if divisor < 0:
        raise f"Divider {divisor} cannot be negative"
    postshift = 0
    while divisor < 1:
        divisor *= 2
        postshift += 1
    p = math.ceil(math.log2(divisor))
    m = math.ceil((1 << (bits + p)) / divisor) & ((1 << bits) - 1)

    prefix = "" if signed else "u"

    types = {n: f"{prefix}int{n}_t" for n in [8, 16, 32, 64]}
    if gnu:
        types[128] = f"__{prefix}int128_t"

    if bits*2 not in types.keys():
        print("Can't generate bit width", bits, "- requires", bits*2, "bit type")
        return None

    itype = types[bits]
    ltype = types[bits*2]

    top_guard = f"""
#ifndef {guard_define}
#define {guard_define}

// Generated by {os.path.basename(__file__)}
#include <stdint.h>
""" if guard_define != None else ""
    bottom_guard = f"""
#endif
""" if guard_define != None else ""
    
    correction = "" if not signed else f"""
    if(n < 0) n += {int(divisor)-1};    
    """

    return f"""
{top_guard}
// Divide by {divisor}
static inline {itype} {name}({itype} n) {{
    {correction}
    {itype} q = ((({ltype}) {m}ULL)*(({ltype}) n)) >> {bits}ULL;
    {itype} t = (((n - q) >> 1) + q) >> {p-1};
    return t << {postshift};
}}
{bottom_guard}
"""

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        "Generates a function to perform floor division by a constant in standard C "
        "via the method here:\n"
        "https://ridiculousfish.com/blog/posts/labor-of-division-episode-i.html\n\n"
        "Bit widths of up to 32 bits (64 on GCC) are supported, and results will be "
        "exact to integer truncation. Floating-point divisors are also supported. "
        "(If you have a modern compiler and are only using integers, your compiler "
        "probably does this already.)\n"
    )

    parser.add_argument("-o", type=str, help="Output header file")
    parser.add_argument("-b", type=int, help="Bit width of calculation", default=32)
    parser.add_argument("-n", type=str, help="Name of function generated")
    parser.add_argument("-g", action='store_true',
                        help="Assume support for GNU-style __uint128_t (otherwise "
                        "64-bit upper multiplies can't be generated)")
    parser.add_argument("divisor", type=float, help="Number to divide by")

    args = parser.parse_args()

    if args.o is not None:
        guard_define = os.path.basename(args.o).upper()\
            .translate({ord(c): "_" for c in "\"\'!@#$%^&*()[]{};:,./<>?\\|`~-=+"})
    else:
        guard_define = "DIVIDER_H"


    if args.divisor <= 0:
        print("Only positive divisors supported")
        exit(-1)

    if args.n is None:
        args.n = "div_" + str(args.divisor).replace(".", "_")

    code_str = make_divider(args.divisor, args.b, args.n, guard_define, args.g)
    if code_str is None:
        exit(-1)

    if args.o is not None:
        with open(args.o, "w") as f:
            f.write(code_str)
    else:
        print(code_str)
