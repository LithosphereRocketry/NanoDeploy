#!/usr/bin/python3

import os
import math
import argparse

parser = argparse.ArgumentParser(
    "Generates a function to perform floor division by a constant in standard C "
    "via the method here:\n"
    "https://ridiculousfish.com/blog/posts/labor-of-division-episode-i.html\n\n"
    "Bit widths of up to 32 bits (64 on GCC) are supported, and results will be "
    "exact to integer truncation. Floating-point divisors are also supported. "
    "(If you have a modern compiler and are only using integers, your compiler "
    "probably does this already.)\n"
)

parser.add_argument("-o", type=str, help="Output header file")
parser.add_argument("-b", type=int, help="Bit width of calculation", default=32)
parser.add_argument("-n", type=str, help="Name of function generated")
parser.add_argument("-g", action='store_true',
                    help="Assume support for GNU-style __uint128_t (otherwise "
                    "64-bit upper multiplies can't be generated)")
parser.add_argument("divisor", type=float, help="Number to divide by")

args = parser.parse_args()

if args.o is not None:
    guard_define = os.path.basename(args.o).upper()\
        .translate({ord(c): "_" for c in "\"\'!@#$%^&*()[]{};:,./<>?\\|`~-=+"})
else:
    guard_define = "DIVIDER_H"


types = {n: f"uint{n}_t" for n in [8, 16, 32, 64]}
if args.g:
    types[128] = "__uint128_t"

if args.b*2 not in types.keys():
    print("Can't generate bit width", args.b, "- requires", args.b*2, "bit type")
    exit(-1)
if args.divisor <= 0:
    print("Only positive divisors supported")
    exit(-1)

itype = types[args.b]
ltype = types[args.b*2]

if args.n is None:
    args.n = "div_" + str(args.divisor).replace(".", "_")

p = math.ceil(math.log2(args.divisor))
m = math.ceil((1 << (args.b + p)) / args.divisor) & ((1 << args.b) - 1)

code_str = f"""// Generated by {os.path.basename(__file__)}

#ifndef {guard_define}
#define {guard_define}

#include <stdint.h>

static inline {itype} {args.n}({itype} n) {{
    {itype} q = ((({ltype}) {m}ULL)*(({ltype}) n)) >> {args.b};
    {itype} t = (((n - q) >> 1) + q) >> {p-1};
    return t;
}}

#endif
"""

if args.o is not None:
    with open(args.o, "w") as f:
        f.write(code_str)
else:
    print(code_str)
